[General]
network = CBS_Max_Latency

**.aggregateSwitch.**.queue[7].*.scalar-recording = true
**.aggregateSwitch.**.queue[7].*.vector-recording = true
**.aggregateSwitch.**.queue[7].*.statistic-recording = true
**.scalar-recording = false
**.vector-recording = false
**.statistic-recording = false

# Arp config
**.arpType = "GlobalARP"
**.max_drift = 0ppm
**.drift_change = 0ppm

## parameter study for number of input links and stages
**.numInputLinks = ${IL=2..13 step 1} ## the actSrcual interesting part is the length of the chain!
**.numStages = ${S=1..20 step 1}

# device mac addresses
**.talkerSrc[*].eth[*].mac.address = "0A-0B-0C-01-01-" + string(10+ancestorIndex(2))
**.ctSrc[*].eth[*].mac.address = "0A-0B-0C-02-" + string(10+ancestorIndex(3)) + "-" + string(10+ancestorIndex(2))
**.sink.eth[*].mac.address = "0A-0B-0C-03-01-01" 
# switch control plane mac addresses 
**.aggregateSwitch.eth[*].mac.address = "0A-00-00-0C-00-01"
**.stageSwitch[*].eth[*].mac.address = "0A-00-00-0C-" + string(10+ancestorIndex(3)) + "-" + string(10+ancestorIndex(2))

# 1 talker per input link talker src
# to model the talker sending more data then initially reserved we use two services per talker
# each talker has the service id of its node index, the second talker
# all services only have one subscriber but we use mcast to be compatible with our TSN stream reservation scheme
**.talkerSrc[*].numServices = 1#2
**.talkerSrc[*].services[*].typename = "Publisher"
**.talkerSrc[*].services[0].display-name = "talker"
**.talkerSrc[*].services[0].serviceName = "talker " + string(parentIndex())
# **.talkerSrc[*].services[1].display-name = "talker++"
# **.talkerSrc[*].services[1].serviceName = "talker++ " + string(parentIndex())
**.talkerSrc[*].services[*].serviceId = parentIndex()*1000 + index
**.talkerSrc[*].services[*].applicationUDPPort = 1000 + (index * 100) + parentIndex()
**.talkerSrc[*].services[*].applicationTCPPort = 2000 + (index * 100) + parentIndex() 
**.talkerSrc[*].services[*].mcastDestPort = 3000 + (index * 100) + parentIndex() 
**.talkerSrc[*].services[*].mcastDestAddress = "224.0.0." + string((index * 100) + parentIndex()+1) 
**.talkerSrc[*].services[*].vlan_id = 0
**.talkerSrc[*].services[*].pcp = 7
# the second source app is only to temporarily add a burst so do not include it in the reservation
# **.talkerSrc[*].services[1].preventReservation = true 
# all talkers send to the same sink node located behind an aggregate switch
# the sink has subscriber per talker node
**.sink.numServices = ${IL} + 1#*2
**.sink.services[*].typename = "Subscriber"
# ct receivers
**.sink.services[0].display-name = "sub-be-ct"
**.sink.services[0].serviceId = 20000 
**.sink.services[*].display-name = "subscriber-" + string(((index-1)%${IL})) + "-" + string(int(floor((index-1)/${IL})))
**.sink.services[*].serviceId = ((index-1)%${IL})*1000 + int(floor((index-1)/${IL}))
**.sink.services[*].applicationUDPPort = 1000 + index 
**.sink.services[*].applicationTCPPort = 2000 + index


# total bw per link should be 75% of 100Mbit/s
# every talker sends with 75% / input links
# intervals are set to 125us 
**.talkerSrc[*].services[0].intervalMin = 0.000125s
**.talkerSrc[*].services[0].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte) 
# the scenario shall repeat every 100ms = irregular tlaker interval
# **.talkerSrc[*].services[1].intervalMin = 100ms
# **.talkerSrc[*].services[1].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte)
# start times
**.sink.services[0].startTime = 100s # do not start ct services by default.
**.sink.services[*].startTime = 0.11s
**.talkerSrc[*].services[*].startTime = 0.1s + 500ns*parentIndex() + 500ns*index

[Config CrossTraffic]
# between the talkers and the sink each input link has a number of stage switches
# each stage has a ct node that sends and receives BE and priority CT 
##### service configuration
**.ctSrc[*].numServices = 4
# priority ct publisher
**.ctSrc[*].services[0].typename = "Publisher"
**.ctSrc[*].services[0].display-name = "pcp7-ct"
**.ctSrc[*].services[0].serviceName = "pcp7-ct-" + string(ancestorIndex(2)) + "-" + string(parentIndex())
**.ctSrc[*].services[0].vlan_id = 0
**.ctSrc[*].services[0].pcp = 7
# priority ct subscriber
**.ctSrc[*].services[1].typename = "Subscriber"
**.ctSrc[*].services[1].display-name = "sub-pcp7"
# BE ct publisher
**.ctSrc[*].services[2].typename = "Publisher"
**.ctSrc[*].services[2].display-name = "be-ct"
**.ctSrc[*].services[2].serviceName = "be-ct-" + string(ancestorIndex(2)) + "-" + string(parentIndex())
**.ctSrc[*].services[2].vlan_id = -1 # supresses the QoS requirements
**.ctSrc[*].services[2].pcp = -1 # supresses the QoS requirements
# BE ct subscriber
**.ctSrc[*].services[3].typename = "Subscriber"
**.ctSrc[*].services[3].display-name = "sub-be"
##### ports and mcast addresses without overlap
# priority ct publisher
**.ctSrc[*].services[0].applicationUDPPort = 1000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].applicationTCPPort = 10000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].mcastDestPort = 2000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].mcastDestAddress = "224.1." + string(ancestorIndex(2)+1) + "." + string(parentIndex()+1) 
# priority ct subscriber
**.ctSrc[*].services[1].applicationUDPPort = 3000 + ancestorIndex(2) * 100 + parentIndex() 
**.ctSrc[*].services[1].applicationTCPPort = 30000 + ancestorIndex(2) * 100 + parentIndex()
# BE ct publisher
**.ctSrc[*].services[2].applicationUDPPort = 4000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[2].applicationTCPPort = 40000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[2].mcastDestPort = 5000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[2].mcastDestAddress = "224.2." + string(ancestorIndex(2)+1) + "." + string(parentIndex()+1) 
# BE ct subscriber
**.ctSrc[*].services[3].applicationUDPPort = 6000 + ancestorIndex(2) * 100 + parentIndex() 
**.ctSrc[*].services[3].applicationTCPPort = 60000 + ancestorIndex(2) * 100 + parentIndex()
##### service ids and connections
# the subscriber of each ct talker is the next stage node
# the first input link must receive the final input link
# the last publisher in line is to be received by the first stage node in the next input link
# all others just subscribe the previous node in line
# priority ct publisher
**.ctSrc[*].services[0].serviceId = (ancestorIndex(2)+1) * 100 + parentIndex()
# priority ct subscriber
**.stage[0].ctSrc[0].services[1].serviceId = (${IL}) * 100 + ${S}-1
**.ctSrc[0].services[1].serviceId = (ancestorIndex(2)) * 100 + ${S}-1
**.ctSrc[*].services[1].serviceId = (ancestorIndex(2)+1) * 100 + parentIndex()-1
# BE ct publisher
**.ctSrc[*].services[2].serviceId = 10000 + (ancestorIndex(2)+1) * 100 + parentIndex()
# BE ct subscriber
**.stage[0].ctSrc[0].services[3].serviceId = 10000 + (${IL}) * 100 + ${S}-1
**.ctSrc[0].services[3].serviceId = 10000 + (ancestorIndex(2)) * 100 + ${S}-1
**.ctSrc[*].services[3].serviceId = 10000 + (ancestorIndex(2)+1) * 100 + parentIndex()-1
##### interval
# the priority ct only occurs ever 100 ms, be traffic every 30ms
# both be an priority ct are active at same time every 300 ms 
**.ctSrc[*].services[0].intervalMin = 100ms
**.ctSrc[*].services[2].intervalMin = 10ms
#### start time
# all apps have a 0.1s offset for network startup
# the publishers send so their frame arrives at the switch just before the talker frame 
# following hops also depend on the delay of the cbs caused by the credit drop from the ct frame with (CTFrame * 8 / 100Mbit/s) * sendslope / idleslope
**.ctSrc[*].services[0].startTime = 0.1s + (500ns*ancestorIndex(2)) + (parentIndex()*8us) + (parentIndex() * second((floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})*8*0.25)/75000000)) + (parentIndex()+1)*second((floor(((75000000/8)*0.000125)/${IL})-12)*8/100000000) + (parentIndex()-1)*second((((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})*8/100000000)
**.ctSrc[*].services[1].startTime = 0.12s
**.ctSrc[*].services[2].startTime = 0.1s + (500ns*ancestorIndex(2)) + (parentIndex()*8us) + (parentIndex()+1)*second((floor(((75000000/8)*0.000125)/${IL})-12)*8/100000000) + (parentIndex()-1)*second(((1526)*8)/100000000)
**.ctSrc[*].services[3].startTime = 0.12s
##### payload
# priority ct publisher sends with the remaining bandwidth required in each input stage to reach 75Mbit/s
**.ctSrc[*].services[0].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte)
**.ctSrc[*].services[2].payloadMax = 1526Byte - 74Byte # max be frame - all headers 

##### aggregate switch cross traffic
**.aggregateCTSrc.numServices = 1
**.aggregateCTSrc.services[*].typename = "Publisher"
**.aggregateCTSrc.services[*].display-name = "be-ct"
**.aggregateCTSrc.services[*].serviceName = "be-ct-aggregate"
**.aggregateCTSrc.services[*].vlan_id = -1 # supresses the QoS requirements
**.aggregateCTSrc.services[*].pcp = -1 # supresses the QoS requirements
##### service ids and connections
**.aggregateCTSrc.services[*].applicationUDPPort = 1000
**.aggregateCTSrc.services[*].applicationTCPPort = 2000
**.aggregateCTSrc.services[*].mcastDestPort = 3000
**.aggregateCTSrc.services[*].mcastDestAddress = "224.3.0." + string(index+1)
**.aggregateCTSrc.services[*].serviceId = 20000
##### interval
**.aggregateCTSrc.services[*].intervalMin = 10ms
#### start time
**.aggregateCTSrc.services[*].startTime = 0.1s + (${S}*8us) + (${S}+1)*second((floor(((75000000/8)*0.000125)/${IL})-12)*8/100000000) + (${S}-1)*second(((1526)*8)/100000000)
##### payload
**.aggregateCTSrc.services[*].payloadMax = 1526Byte - 74Byte # max be frame - all headers 
##### start sinks
**.sink.services[0].startTime = 0.12s # do not start ct services by default.

[Config BECrossTraffic]
extends=CrossTraffic
# register high prio ct but never acutally send a message, stop when subscriber registers
**.ctSrc[*].services[0].stopTime = 0.12s

[Config PriorityCrossTraffic]
extends=CrossTraffic
# register be ct but never acutally send a message, stop when subscriber registers
**.ctSrc[*].services[2].stopTime = 0.12s
**.aggregateCTSrc[*].services[*].startTime = 0.1s + (${S}*8us) + (${S} * second((floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})*8*0.25)/75000000)) + (${S})*second((floor(((75000000/8)*0.000125)/${IL})-12)*8/100000000) + (${S})*second((((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})*8/100000000) - second(((1526)*8)/100000000

[Config VerifyMaxLatency]
**.controllerApps[2].verifyMaxLatencies = true
**.controllerApps[2].portTransmitRate = 100Mbps
**.controllerApps[2].dumpFlowUpdatesToFile = "flowUpdates.json"

[Config StaticReservation]
**controllerApps[2].reserveResources = false ## no reservation changes, everything static
**.*Switch*.etherMAC[*].shaper.transmissionSelectionAlgorithm[7].staticIdleSlope = 75Mbps

[Config StdCmi]
**.streamIntervalAsCMI = false
**.pcpCMI = {7:125us}

[Config StreamInterval]
**.streamIntervalAsCMI = true
# TODO requires changes when combining with PriorityCrossTraffic

[Config NC]
**.streamIntervalAsCMI = false
# TODO static config list from NC framework output

#################################################
#################### STUDIES ####################
#################################################
[Config Study_BECT_StaticReservation]
extends=BECrossTraffic, VerifyMaxLatency, StaticReservation

[Config Study_PrioCT_StaticReservation]
extends=PriorityCrossTraffic, VerifyMaxLatency, StaticReservation

[Config Study_BECT_StdCmi]
extends=BECrossTraffic, VerifyMaxLatency, StdCmi

[Config Study_PrioCT_StdCmi]
extends=PriorityCrossTraffic, VerifyMaxLatency, StdCmi

