[General]
network = CBS_Max_Latency

# Arp config
**.arpType = "GlobalARP"

## parameter study for number of input links and stages
**.numInputLinks = ${IL=2..13 step 1} ## the actSrcual interesting part is the length of the chain!
**.numStages = ${S=1..20 step 1}

# device mac addresses
**.talkerSrc[*].eth[*].mac.address = "0A-0B-0C-01-01-" + string(10+ancestorIndex(2))
**.ctSrc[*].eth[*].mac.address = "0A-0B-0C-02-" + string(10+ancestorIndex(3)) + "-" + string(10+ancestorIndex(2))
**.sink.eth[*].mac.address = "0A-0B-0C-03-01-01" 
# switch control plane mac addresses 
**.aggregateSwitch.eth[*].mac.address = "0A-00-00-0C-00-01"
**.stageSwitch[*].eth[*].mac.address = "0A-00-00-0C-" + string(10+ancestorIndex(3)) + "-" + string(10+ancestorIndex(2))

# 1 talker per input link talker src
# to model the talker sending more data then initially reserved we use two services per talker
# each talker has the service id of its node index, the second talker
# all services only have one subscriber but we use mcast to be compatible with our TSN stream reservation scheme
**.talkerSrc[*].numServices = 1#2
**.talkerSrc[*].services[*].typename = "Publisher"
**.talkerSrc[*].services[0].display-name = "talker"
**.talkerSrc[*].services[0].serviceName = "talker " + string(parentIndex())
# **.talkerSrc[*].services[1].display-name = "talker++"
# **.talkerSrc[*].services[1].serviceName = "talker++ " + string(parentIndex())
**.talkerSrc[*].services[*].serviceId = parentIndex()*1000 + index
**.talkerSrc[*].services[*].applicationUDPPort = 1000 + (index * 100) + parentIndex()
**.talkerSrc[*].services[*].applicationTCPPort = 2000 + (index * 100) + parentIndex() 
**.talkerSrc[*].services[*].mcastDestPort = 3000 + (index * 100) + parentIndex() 
**.talkerSrc[*].services[*].mcastDestAddress = "224.0.0." + string((index * 100) + parentIndex()+1) 
**.talkerSrc[*].services[*].vlan_id = 0
**.talkerSrc[*].services[*].pcp = 7
# the second source app is only to temporarily add a burst so do not include it in the reservation
# **.talkerSrc[*].services[1].preventReservation = true 
# all talkers send to the same sink node located behind an aggregate switch
# the sink has subscriber per talker node
**.sink.numServices = ${IL}#*2
**.sink.services[*].typename = "Subscriber"
**.sink.services[*].display-name = "subscriber-" + string((index%${IL})) + "-" + string(int(floor(index/${IL})))
**.sink.services[*].serviceId = (index%${IL})*1000 + int(floor(index/${IL}))
**.sink.services[*].applicationUDPPort = 1000 + index 
**.sink.services[*].applicationTCPPort = 2000 + index

# between the talkers and the sink each input link has a number of stage switches
# each stage has a ct node that has both a subscriber and a publisher services
**.ctSrc[*].numServices = 2
**.ctSrc[*].services[0].typename = "Publisher"
**.ctSrc[*].services[0].display-name = "ct-talker"
**.ctSrc[*].services[0].serviceName = "ct-" + string(ancestorIndex(2)) + "-" + string(parentIndex())
**.ctSrc[*].services[0].serviceId = (ancestorIndex(2)+1) * 100 + parentIndex()
**.ctSrc[*].services[0].applicationUDPPort = 4000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].applicationTCPPort = 5000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].mcastDestPort = 6000 + ancestorIndex(2) * 100 + parentIndex()
**.ctSrc[*].services[0].mcastDestAddress = "224.1." + string(ancestorIndex(2)+1) + "." + string(parentIndex()+1) 
**.ctSrc[*].services[0].vlan_id = 0
**.ctSrc[*].services[0].pcp = 7
# the subscriber of each ct talker is the next stage node
**.ctSrc[*].services[1].typename = "Subscriber"
**.ctSrc[*].services[1].display-name = "subscriber"
# the first input link must receive the final input link
**.stage[0].ctSrc[0].services[1].serviceId = (${IL}) * 100 + ${S}-1
# the last publisher in line is to be received by the first stage node in the next input link
**.ctSrc[0].services[1].serviceId = (ancestorIndex(2)) * 100 + ${S}-1
# all others just subscribe the previous node in line
**.ctSrc[*].services[1].serviceId = (ancestorIndex(2)+1) * 100 + parentIndex()-1
**.ctSrc[*].services[1].applicationUDPPort = 1000 + ancestorIndex(2) * 100 + parentIndex() 
**.ctSrc[*].services[1].applicationTCPPort = 2000 + ancestorIndex(2) * 100 + parentIndex()

# total bw per ling should be 75% of 100Mbit/s
# every talker sends with 75% / input links
# intervals are set to 125us for all regular talkers
**.talkerSrc[*].services[0].intervalMin = 0.000125s
**.talkerSrc[*].services[0].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte) 
# the scenario shall repeat every 100ms = ct talker interval and irregular tlaker interval
# **.talkerSrc[*].services[1].intervalMin = 100ms
# **.talkerSrc[*].services[1].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte)
# ct nodes
**.ctSrc[*].services[0].intervalMin = 100ms
**.ctSrc[*].services[0].payloadMax = intWithUnit(byte(floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL})) - 12Byte - 74Byte)
# start times
**.sink.services[*].startTime = 0.11s
**.talkerSrc[*].services[*].startTime = 0.1s + 500ns*parentIndex() + 500ns*index
**.ctSrc[*].services[0].startTime = 0.1s + (500ns*parentIndex()) + (parentIndex()*8us) + (parentIndex()+1)*second((floor(((75000000/8)*0.000125)/${IL}))*8/100000000) + (parentIndex()-1)*second((floor(((75000000/8)*0.000125)-((75000000/8)*0.000125)/${IL}))*8/100000000)
**.ctSrc[*].services[1].startTime = 0.12s


[Config Recordings]
**.aggregateSwitch.**.queue[7].*.scalar-recording = true
**.aggregateSwitch.**.queue[7].*.vector-recording = true
**.aggregateSwitch.**.queue[7].*.statistic-recording = true
**.scalar-recording = false
**.vector-recording = false
**.statistic-recording = false

[Config VerifyMaxLatency]
**.controllerApps[2].verifyMaxLatencies = true
**.controllerApps[2].portTransmitRate = 100Mbps
**.controllerApps[2].dumpFlowUpdatesToFile = "flowUpdates.json"

[Config StdCmi]
extends=VerifyMaxLatency,Recordings
# controller
**.streamIntervalAsCMI = false
**.pcpCMI = {7:125us}

[Config StreamInterval]
extends=VerifyMaxLatency,Recordings
**.streamIntervalAsCMI = true

[Config NC]
extends=Recordings
**.streamIntervalAsCMI = false
# TODO static config list from NC framework output